[[决策树]]
# 1.基本概念
规则(rule): 机器学习中"规则"通常是语义明确 ,能描述数据分布所隐含的客观规律或领域概念, 可写成"若......则......"形式的**逻辑规则**.

规则学习(rule learning): 从训练数据中学习出一组能用于对未见示例进行判别的规则.
*(所有预测模型广义上都可以算一个/一组"规则",规则学习这里实际上是省略了"逻辑"的狭义"规则")*

形式化来看,一条规则形如:$$\oplus \leftarrow \mathbf f_1 \land \mathbf f_2 \land \cdots \land \mathbf f_L$$
$\leftarrow$:逻辑蕴含符号
右边部分:规则体(body),表示该条规则的前提.
左边部分:规则头(head) ,表示该条规则的结果.

规则体:由逻辑文字(literal) $\mathbf f_k$ 组成的合取式(conjunction),合取符号$\land$表示"并且".每个文字 $\mathbf f_k$ 都是对示例属性进行检验的布尔表达式.     $L$ : 规则的长度, 是规则体中逻辑文字的个数
规则头的$\oplus$ 同样是逻辑文字,一般用来表示规则所判定的目标类别或概念.
*(数理逻辑中,"文字"专指原子公式(atom)及其否定)*

规则学习可解释性好,便于引入领域知识,抽象描述能力在解决复杂问题时很有用.

假定我们从西瓜数据集上学得规则集合$\mathcal R$:
	规则1:$好瓜\leftarrow (根蒂=蜷缩)\land(脐部=凹陷);$
	规则2:$\lnot 好瓜\leftarrow (纹理=模糊);$
规则1长度为2,通过判断两个逻辑文字的赋值(valuation)来对示例进行判别.
符合该规则的样本称为被该规则 **"覆盖"**(cover).    *注意:未被规则1覆盖不一定不是好瓜*

规则集合中的每条规则可被看作一个子模型,规则模型是这些子模型的一个集成.[[集成学习]]
当一个示例被判别结果不同的多条规则覆盖时,称发生了 **"冲突"**(conflict).

**冲突消解(conflict resolution)**:解决冲突的办法
常用
1. 投票法
2. 排序法: 在规则集合上定义一个顺序,冲突时使用最靠前的规则;相应的规则学习的过程称为"带序规则学习"或"优先级学习".
3. 元规则法: 根据领域知识事先制定一些 **"元规则(meta-rule)"**,即规则的规则(eg:发生冲突时使用长度最小的规则)

此外,学得的规则集合可能不能覆盖所有的未见示例,so,制定 **"默认规则"(default rule)**.
eg:对上面的$\mathcal R$,未被上述两条规则覆盖的都是坏瓜

从形式语言表达能力而言,规则可分为两类
1. **命题规则**(propositional rule)
   由 **原子命题**(propositional atom)和逻辑连接词构成的简单陈述句.
   eg:"根蒂=凹陷"就是一个原子命题,规则集$\mathcal R$就是一个命题规则集.
2. **一阶规则**(first-order rule) 
   基本成分:能描述事物的属性或关系的 **"原子公式"**(atomic formula).
   会用到谓词(predicate),函数,量词(quantifier).<br><br>一阶规则能表达复杂的关系,因此也被称为"关系型规则"(relational rule).
命题规则集$\mathcal R$可改写为一阶规则集$\mathcal R'$:
	规则1:$好瓜(X)\leftarrow 根蒂(X,蜷缩)\land脐部(X,凹陷);$
	规则2:$\lnot 好瓜(X)\leftarrow 纹理(X,模糊);$
显然,命题规则是一阶规则的特例

# 2.序贯覆盖
**规则学习的目标**: 产生一个能覆盖尽可能多的样例的规则集.

so,最简单的:"**序贯覆盖**(sequential covering)",即逐条归纳
>[!tldr]
>在训练集上每学到一条规则,就将该规则覆盖到的训练样例去除.
>以剩下的样例组成的新训练集重复

由于每次只处理一部分数据,因此也被称为"分治"(separate-and-conquer)策略

以命题规则为例,序贯覆盖法的关键: 如何从训练集中学出单条规则.
对学习目标$\oplus$,产生一条规则就是寻找最优的一组逻辑文字来构成规则体,这是一个*搜索问题*.

给定正例集合和反例集合,学习任务是基于候选文字集合$\mathcal F=\{\mathbf f_k\}$来生成最优规则$\mathbf r$.命题规则学习中,候选文字是形如"$R(属性_i,属性值_{i,j})$"的布尔表达式.$(eg: \mathcal F=\{色泽=青绿?,色泽=乌黑?,...,\})$.

最简单的做法,穷举所有组合,找到最优.[[序贯覆盖--穷举 在西瓜数据集上的示例]]

现实中:
1. "自顶向下":从比较一般的规则开始,逐渐添加新文字以缩小规则覆盖范围,直到达到预定<br>亦称"生成-测试",是规则逐渐"特化"的过程.<br>*如不含任何属性的空规则*<br>注:与穷举不同,自顶向下寻找的是每一步的局部最优<br>
2. "自底向上":从比较特殊的规则开始,逐渐删除文字以扩大规则覆盖范围,直到满足条件.<br>亦称"数据驱动"法,是规则"泛化"的过程.<br>*如直接以某样例的属性取值形成规则,则该规则只覆盖此样例*

| 策略   | 特点                     | 常用场景                |
| ---- | ---------------------- | ------------------- |
| 自顶向下 | 易于产生泛化性能较好的规则,对噪声的鲁棒性强 | 命题规则学习              |
| 自底向上 | 更适合训练样本较少的情形,对噪声的鲁棒性差  | 一阶规则学习这类假设空间非常复杂的任务 |
[[自顶向下在西瓜数据集上的示例]]
规则生成过程中涉及一个评估规则优劣的标准.
上面的例子使用的标准是:先考虑规则准确率,准确率相同时考虑覆盖样例数,再相同时考虑属性次序. 现实中可根据具体任务设计不同的标准.

此外,上例中每次仅考虑一个"最优",易陷入局部最优.通常采用温和一点的做法
比如"**集数搜索**"(beam search)
 每轮保留最优的b个逻辑文字,在下一轮中均用于构建候选集,(假设一共有k个候选文字,则下一轮中有b\*k个候选集),然后再选择b个最优的用于下一轮.

序贯覆盖法简单有效,几乎所有的规则学习算法都以它为基本框架.
它能方便的**推广到多分类**问题上,只需将每类分别处理:   学习关于第c类的规则时,将其余所有类别都当作反例.

# 3.剪枝优化
[[决策树--剪枝]]    [[2.4统计显著性检验]]